[TOC]

> go interface{} 定义加强　<http://c.biancheng.net/view/77.html>

# 简介

*   `gRPC`  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计，带来诸如`双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性`。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。
*   在 `gRPC` 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。
*   `gRPC `默认使用` protocol buffers`，这是 Google 开源的一套成熟的结构数据序列化机制，它的作用与 `XML、json `类似，但它是二进制格式，性能好、效率高（缺点：可读性差）

# 1. 环境安装配置

下载客户端：　<https://github.com/protocolbuffers/protobuf/releases>

解压后在bin目录找到protoc.exe，（可以把它复制到GOBIN目录下,或者添加到`/usr/bin/`）

运行`protoc --version`证明成功

## 相关包

安装 golang 的proto工具包

安装 goalng 的proto编译支持

安装 gRPC 包

```bash
go get -u github.com/golang/protobuf/proto
go get -u github.com/golang/protobuf/protoc-gen-go
go get -u google.golang.org/grpc
```

## `vscode`插件

*   `VSCode-proto3`
*   添加`settings.json`设置

```json
   // vscode-proto3插件配置
    "protoc": {
        // protoc.exe所在目录
        "path": "/usr/bin/protoc",
        // 保存时自动编译
        "compile_on_save": true,
        "options": [
            // go编译输出指令, 会默认使用相对路径
            "--go_out=plugins=grpc:."
        ]
    }
```

# 2. `proto`文件编写

## 2.1 基本变量

**在定义 `proto `文件的时候，相同文件夹下的`proto`文件也应声明为同一的 `package`，`并且和文件夹同名`**，这是因为生成的 `pb.go` 文件的 `package` 是取自 `proto package` 的。

编写实例:

```protobuf
syntax = "proto3";  
package user;  // 声明所在包
option go_package = "github.com/I-loner/go_project/proto/simple";  // 声明生成的 go 文件所属的包
  
import "proto/user/message.proto";  // 导入同包内的其他 proto 文件
import "proto/article/message.proto";  // 导入其他包的 proto 文件
  
service User {  
    rpc GetUserInfo (UserID) returns (UserInfo);  
    rpc GetUserFavArticle (UserID) returns (article.Articles.Article);  
}
```

执行`protoc`命令

```bash
protoc --go_out=paths=source_relative:.   ./proto/user/*.proto 
```

**请切记 `option go_package` 声明和 `--go_out=paths=source_relative:.` 命令行参数缺一不可** 。

*   `option go_package` 声明 是为了让生成的其他 go 包（依赖方）可以正确 `import` 到本包（被依赖方）
*   `--go_out=paths=source_relative:.` 参数 是为了让加了 `option go_package` 声明的 proto 文件可以将 go 代码编译到与其同级目录。

文件目录:

```bash
└── proto
        └── user
                ├── user.pb.go
                └── user.proto
```

`user.pb.go`文件:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.21.0
// 	protoc        v3.11.4
// source:  proto/user/user.proto

package user
....
```

***

# 3 `gRPC`请求和响应模式

主要分为四种:

*   `简单模式(Simple RPC)`：客户端发起请求并等待服务端响应。
*   `服务端流式（Server-side streaming RPC）`：客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。
*   `客户端流式（Client-side streaming RPC）`：与服务端数据流模式相反，这次是客户端源源不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。
*   `双向流式（Bidirectional streaming RPC）`：双方使用读写流去发送一个消息序列，两个流独立操作，双方可以同时发送和同时接收。

# 3.1 简单模式

## 新建`proto`文件

```protobuf
syntax = "proto3";// 协议为proto3

package proto;
option go_package="./proto";

//
// 定义发送请求信息
message SimpleRequest{
    // 定义发送的参数
    // 参数类型 参数名 标识号(不可重复)
    string data = 1;
}

// 定义响应信息
message SimpleResponse{
    // 定义接收的参数
    // 参数类型 参数名 标识号(不可重复)
    int32 code = 1;
    string value = 2;
}

// 定义我们的服务（可定义多个服务,每个服务可定义多个接口）
service Simple{
    rpc Route (SimpleRequest) returns (SimpleResponse){};
}
```

编译命令

```bash
# vscode
"protoc": {
        "path": "/usr/bin/protoc",
        "compile_on_save": true,
        "options": [,
            "--go_out=plugins=grpc:./",
        ]
    }
    
# bash
protoc --go_out=plugins=grpc:./ ./simple.proto
    
```

## 创建`Server`端

需要实现`Route`结构方法，给`grpcClient`调用

```go
package main

import (
	"context"
	"log"
	"net"
	"net/http"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

//SimpleService 定义服务
type SimpleService struct{}

//Route 实现Route, 为了让client客户端远程调用Route方法
func (s *SimpleService) Route(ctx context.Context, req *proto.SimpleRequest) (*proto.SimpleResponse, error) {
	res := proto.SimpleResponse{
		Code:  http.StatusOK,
		Value: "hello" + req.Data,
	}
	return &res, nil
}

const (
	// Address 监听地址
	Address string = ":8000"
	// Network 通信协议
	Network string = "tcp"
)

// 启动grpc服务器
func main() {
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v\n", err)
	}
	log.Println(Address + " net.Listening...")

	grpcServer := grpc.NewServer()

	proto.RegisterSimpleServer(grpcServer, &SimpleService{})
	reflection.Register(grpcServer)		//允许调试

	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v\n", err)
	}
}

```

## 创建客户端

需要使用`grpcClient.Route`方法调用远程

```go
package main

import (
	"context"
	"log"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

const (
	//Address 连接地址
	Address string = ":8000"
)

func main() {
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("net.Connect err: %v \n", err)
	}

	defer conn.Close()
	//　建立gRPC连接
	grpcClient := proto.NewSimpleClient(conn)
	// 创建发送结构体
	req := proto.SimpleRequest{
		Data: "grpc",
	}

	// 调用我们的服务(Route方法)
	// 同时传入了一个context.Context, 在需要时可以改变RPC行为
	// 远程调用　调用客户端Route方法
	res, err := grpcClient.Route(context.Background(), &req)
	if err != nil {
		log.Fatalf("Call Route err: %v", err)
	}

	log.Println(res)
}

```

# 3.2 服务端流式`RPC`

**当数据量大或者需要不断传输数据时候，我们应该使用流式`RPC`，它允许我们边处理边传输数据。**

`服务端流式RPC`: 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。

## 情景模拟：实时获取股票走势

## 新建`proto`文件

新近啊`server_stream.proto`文件

使用`stream`关键字

```protobuf
// 定义发送请求信息
message SimpleRequest{
    // 定义发送的参数，采用驼峰命名方式，小写加下划线，如：student_name
    // 请求参数
    string data = 1;
}

// 定义流式响应信息
message StreamResponse{
    // 流式响应数据
    string stream_value = 1;
}

// 定义我们的服务（可定义多个服务,每个服务可定义多个接口）
service StreamServer{
    // 服务端流式rpc，在响应数据前添加stream
    rpc ListValue(SimpleRequest)returns(stream StreamResponse){};
}
```

最后进行编译, 生成`server_stream.pb.go`文件

## 创建`Server`端并且启动`gRPC`服务器

根据接口实现`ListValue`方法

```go
package main

import (
	"log"
	"net"
	"strconv"
	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

// StreamService 定义我们服务
type StreamService struct{}

// ListValue 实现
// server_stream.proto里面 StreamServerServer 有接口定义
func (s *StreamService) ListValue(req *proto.SimpleRequest, srv proto.StreamServer_ListValueServer) error {
	for n := 0; n < 5; n++ {
		//向流中发送消息，默认每次发送消息最大长度为 math.MaxInt32 bytes
		err := srv.Send(&proto.StreamResponse{
			StreamValue: req.Data + strconv.Itoa(n),
		})
		if err != nil {
			return err
		}
	}
	return nil
}

const (
	// Address 监听地址
	Address string = ":8000"
	// Network 网络通信协议
	Network string = "tcp"
)

func main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	log.Println(Address + " net.Listing...")
	// 新建gRPC服务器实例
	// 默认单次接收最大消息长度为`1024*1024*4`bytes(4M)，单次发送消息最大长度为`math.MaxInt32`bytes
	// grpcServer := grpc.NewServer(grpc.MaxRecvMsgSize(1024*1024*4), grpc.MaxSendMsgSize(math.MaxInt32))
	grpcServer := grpc.NewServer()
	// 在gRPC服务器注册我们的服务
	proto.RegisterStreamServerServer(grpcServer, &StreamService{})

	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
}

```

`ListValue`接口定义可以查看`server_stream.pb.go`文件

```go
// StreamServerServer is the server API for StreamServer service.
type StreamServerServer interface {
	//　服务端流式rpc
	ListValue(*SimpleRequest, StreamServer_ListValueServer) error
}

```

## 创建`Client`端

```go
package main

import (
	"context"
	"io"
	"log"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

const (
	//Address 连接地址
	Address string = ":8000"
)

var grpcClient proto.StreamServerClient

func listValue() {
	// 创建发送结构体
	req := proto.SimpleRequest{
		Data: "stream server grpc",
	}

	// 调用服务
	stream, err := grpcClient.ListValue(context.Background(), &req)
	if err != nil {
		log.Fatalf("Call ListStr err: %v", err)
	}

	for {
		//Recv() 方法接收服务端消息，默认每次Recv()最大消息长度为`1024*1024*4`bytes(4M)
		res, err := stream.Recv()
		if err == io.EOF {
			log.Println("收到 io.EOF: ", res)
			break
		}
		if err != nil {
			log.Fatalf("ListStr get stream err: %v", err)
		}
		// 打印返回值
		log.Println(res.StreamValue)
	}

}

func main() {
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("net.Connect err: %v \n", err)
	}

	defer conn.Close()
	// 建立gRPC连接
	grpcClient = proto.NewStreamServerClient(conn)
	listValue()
}

```

客户端不断从服务端获取数据

## 客户端自己停止获取数据

服务端`ListValue`方法修改，只是为了模拟服务端服务不断发送，看到暂停效果,`time.sleep`

```go
// ListValue 实现ListValue方法
func (s *StreamService) ListValue(req *pb.SimpleRequest, srv pb.StreamServer_ListValueServer) error {
	for n := 0; n < 15; n++ {
		// 向流中发送消息， 默认每次send送消息最大长度为`math.MaxInt32`bytes
		err := srv.Send(&pb.StreamResponse{
			StreamValue: req.Data + strconv.Itoa(n),
		})
		if err != nil {
			return err
		}
		log.Println(n)
		time.Sleep(1 * time.Second)
	}
	return nil
}
```

修改客户端`ListValue`方法实现

```go
// listValue 调用服务端的ListValue方法
func listValue() {
	// 创建发送结构体
	req := pb.SimpleRequest{
		Data: "stream server grpc ",
	}
	// 调用我们的服务(Route方法)
	// 同时传入了一个 context.Context ，在有需要时可以让我们改变RPC的行为，比如超时/取消一个正在运行的RPC
	stream, err := grpcClient.ListValue(context.Background(), &req)
	if err != nil {
		log.Fatalf("Call ListStr err: %v", err)
	}
	for n < 5 {
		//Recv() 方法接收服务端消息，默认每次Recv()最大消息长度为`1024*1024*4`bytes(4M)
		res, err := stream.Recv()
		// 判断消息流是否已经结束
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("ListStr get stream err: %v", err)
		}
		// 打印返回值
		log.Println(res.StreamValue)
        // 运行一次，继续走下面
		n ++
	}
	//可以使用CloseSend()关闭stream，这样服务端就不会继续产生流消息
	//调用CloseSend()后，若继续调用Recv()，会重新激活stream，接着之前结果获取消息
	stream.CloseSend()
    
    // 若继续调用 Recv() 可以重新激活
    res, err := stream.Recv()
    log.Println(res.StreamValue)
}
```

返回结果

```bash
# server
2020/05/03 17:28:14 0
2020/05/03 17:28:15 1
2020/05/03 17:28:16 2
2020/05/03 17:28:17 3
2020/05/03 17:28:18 4

# client
2020/05/03 17:28:14 stream server grpc 0
2020/05/03 17:28:15 stream server grpc 1
2020/05/03 17:28:16 stream server grpc 2
2020/05/03 17:28:17 stream server grpc 3
2020/05/03 17:28:18 stream server grpc 4
```

调用`CloseSend()`客户端可以暂停获取，服务端会继续运行，

继续调用`Recv()`的话，就会重新激活客户端，接着之前结果获取消息

# 3.3 客户端流式`RPC`

`客户端流式RPC`：与`服务端流式RPC`相反，客户端不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。

## 情景模拟：客户端大量数据上传到服务端

## 创建`protoc`

客户端前定义添加`stream`

```protobuf
syntax = "proto3";// 协议为proto3

package proto;
option go_package="./proto";

message StreamRequest{
    //流失请求参数
    string stream_data = 1;

}

message SimpleResponse{
    //响应码
    int32 code = 1;
    //响应值
    string value = 2;
}

service StreamClient{
    //客户端流式rpc,在请求的参数前添加stream
    rpc RouteList (stream StreamRequest) returns (SimpleResponse){};
}

```

## 编写`server.go`

```go
package main

import (
	"io"
	"log"
	"net"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

// SimpleService 定义我们的服务
type SimpleService struct{}

// RouteList 实现RouteList方法
func (s *SimpleService) RouteList(srv proto.StreamClient_RouteListServer) error {
	var n int
	for n < 3 {
		//从流中获取消息
		res, err := srv.Recv()
		if err == io.EOF {
			//发送结果，并关闭
			return srv.SendAndClose(&proto.SimpleResponse{Value: "ok"})
		}
		if err != nil {
			return err
		}
		// 打印数据
		log.Println(res.StreamData)
		n++
        // 模拟服务端中断消息发送
	}
	return srv.SendAndClose(&proto.SimpleResponse{Value: "ok quickly"})
}

const (
	// Address 监听地址
	Address string = ":8000"
	// Network 网络通信协议
	Network string = "tcp"
)

func main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	log.Println(Address + " net.Listing...")
	// 新建gRPC服务器实例
	grpcServer := grpc.NewServer()
	// 在gRPC服务器注册我们的服务
	proto.RegisterStreamClientServer(grpcServer, &SimpleService{})

	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
}

```

## `client.go`

如果会有服务端主动终止情况，需要`client`主动判断`EOF`停止再发送，如果继续`send()`会报错

```go
package main

import (
	"context"
	"io"
	"log"
	"strconv"
	"time"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

const (
	//Address 连接地址
	Address string = ":8000"
)

var streamClient proto.StreamClientClient

// routeList 调用服务端RouteList方法
func routeList() {
	//调用服务端RouteList方法，获流
	stream, err := streamClient.RouteList(context.Background())
	if err != nil {
		log.Fatalf("Upload list err: %v", err)
	}
	for n := 0; n < 5; n++ {
		//向流中发送消息
		err := stream.Send(&proto.StreamRequest{StreamData: "stream client rpc " + strconv.Itoa(n)})
		// 可能服务端终端了，会发送io.EOF，如果不主动中断继续send会报错
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatalf("stream request err: %v", err)
		}

		time.Sleep(time.Second * 1)
		log.Println("Sendng message")
	}
	//关闭流并获取返回的消息
	res, err := stream.CloseAndRecv()
	if err != nil {
		log.Fatalf("RouteList get response err: %v", err)
	}
	log.Println(res)
}

func main() {
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("net.Connect err: %v \n", err)
	}

	defer conn.Close()
	// 建立gRPC连接
	streamClient = proto.NewStreamClientClient(conn)
	routeList()
}

```

# 3.4 双向流式`RPC`

## 情景模拟：双方对话

## 新建`both_stream.proto`

```protobuf
syntax = "proto3";// 协议为proto3

package proto;
option go_package="./proto";

message StreamRequest{
    string question = 1;
}

message StreamResponse{
    string answer = 1;
}

service Stream{
    // 双向流式rpc，同时在请求参数前和响应参数前加上stream
    rpc Conversations(stream StreamRequest) returns(stream StreamResponse){};
}
```

## `server.go`

```go
package main

import (
	"io"
	"log"
	"net"
	"strconv"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

// StreamService 定义我们的服务
type StreamService struct{}

// Conversations 实现Conversations方法
func (s *StreamService) Conversations(srv proto.Stream_ConversationsServer) error {
	n := 1
	for {
		req, err := srv.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		err = srv.Send(&proto.StreamResponse{
			Answer: "from stream server answer: the " + strconv.Itoa(n) + " question is " + req.Question,
		})
		if err != nil {
			return err
		}
		n++
		log.Printf("from stream client question: %s", req.Question)
	}
}

const (
	// Address 监听地址
	Address string = ":8000"
	// Network 网络通信协议
	Network string = "tcp"
)

func main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	log.Println(Address + " net.Listing...")
	// 新建gRPC服务器实例
	grpcServer := grpc.NewServer()
	// 在gRPC服务器注册我们的服务
	proto.RegisterStreamServer(grpcServer, &StreamService{})

	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
}

```

## `client.go`

```go
package main

import (
	"context"
	"io"
	"log"
	"strconv"
	"time"

	"github.com/I-loner/go_project/proto"
	"google.golang.org/grpc"
)

const (
	//Address 连接地址
	Address string = ":8000"
)

var streamClient proto.StreamClient

// conversations 调用服务端的Conversations方法
func conversations() {
	//调用服务端的Conversations方法，获取流
	stream, err := streamClient.Conversations(context.Background())
	if err != nil {
		log.Fatalf("get conversations stream err: %v", err)
	}
	for n := 0; n < 5; n++ {
		err := stream.Send(&proto.StreamRequest{Question: "stream client rpc " + strconv.Itoa(n)})
		if err != nil {
			log.Fatalf("stream request err: %v", err)
		}
		res, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("Conversations get stream err: %v", err)
		}
		// 打印返回值
		log.Println(res.Answer)
		time.Sleep(time.Second)
	}
	//最后关闭流
	err = stream.CloseSend()
	if err != nil {
		log.Fatalf("Conversations close stream err: %v", err)
	}
}

func main() {
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("net.Connect err: %v \n", err)
	}

	defer conn.Close()
	// 建立gRPC连接
	streamClient = proto.NewStreamClient(conn)
	conversations()
}

```

# 4 超时设置

`gRPC`默认的请求的超时时间是很长的，当你没有设置请求超时时间时，所有在运行的请求都占用大量资源且可能运行很长的时间，导致服务资源损耗过高，使得后来的请求响应过慢，甚至会引起整个进程崩溃。

## 客户端请求设置超时时间

修改调用服务端方法

1.把超时时间设置为当前时间`+3秒`

```go
	clientDeadline := time.Now().Add(time.Duration(3 * time.Second))
	ctx, cancel := context.WithDeadline(ctx, clientDeadline)
	defer cancel()
```

2.响应错误检测中添加超时检测

```go
       // 传入超时时间为3秒的ctx
	res, err := grpcClient.Route(ctx, &req)
	if err != nil {
		//获取错误状态
		statu, ok := status.FromError(err)
		if ok {
			//判断是否为调用超时
			if statu.Code() == codes.DeadlineExceeded {
				log.Fatalln("Route timeout!")
			}
		}
		log.Fatalf("Call Route err: %v", err)
	}
	// 打印返回值
	log.Println(res.Value)
```

## 服务端判断请求是否超时

一般地，在耗时操作或写库前进行超时检测，发现超时就停止工作。

```go
// Route 实现Route方法
func (s *SimpleService) Route(ctx context.Context, req *pb.SimpleRequest) (*pb.SimpleResponse, error) {
	timeout := make(chan struct{}, 1)
	data := make(chan *pb.SimpleResponse, 1)
	go func() {
		time.Sleep(4 * time.Second)
		res := pb.SimpleResponse{
			Code:  200,
			Value: "hello " + req.Data,
		}
		log.Println("goroutine still running")
		data <- &res
	}()
	go func() {
		for {
			if ctx.Err() == context.Canceled {
				timeout <- struct{}{}
			}
		}
	}()
	select {
	case res := <-data:
		return res, nil
	case <-timeout:
		return nil, status.Errorf(codes.Canceled, "Client cancelled, abandoning.")
	}
}
```

当超时后，获取数据的`goroutine`仍然在运行，并不能避免资源浪费。所以还是那句话，在耗时操作或写库前进行超时检测，发现超时就停止工作。

# 5 `TLS`认证＋自定义方法认证

## `TLS`证书认证

> `TLS`（Transport Layer Security，安全传输层)，`TLS`是建立在`传输层`TCP协议之上的协议，服务于应用层，它的前身是`SSL（Secure Socket Layer，安全套接字层）`，它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。

生成`RSA`私钥

```bash
openssl genrsa -out server.key 2048
```

> 生成`RSA`私钥，命令的最后一个参数，将指定生成密钥的位数，如果没有指定，默认512

生成`ECC`私钥

```bash
openssl ecparam -genkey -name secp384r1 -out server.key
```

> 生成`ECC`私钥，命令为椭圆曲线密钥参数生成及操作，本文中`ECC`曲线选择的是`secp384r1`

生成公钥

```bash
openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
```

> `openssl req`：生成自签名证书，`-new指生成证书请求`、`-sha256指使用sha256加密`、`-key指定私钥文件`、`-x509指输出证书`、`-days 3650为有效期`

此后则输入证书拥有者信息

```bash
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:XxXx
Locality Name (eg, city) []:XxXx
Organization Name (eg, company) [Internet Widgits Pty Ltd]:XX Co. Ltd
Organizational Unit Name (eg, section) []:Dev
Common Name (e.g. server FQDN or YOUR name) []:go-grpc-example
Email Address []:xxx@xxx.com
```

### 服务端构建`TLS`证书并认证

```go
func main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	// 从输入证书文件和密钥文件为服务端构造TLS凭证
	creds, err := credentials.NewServerTLSFromFile("../pkg/tls/server.pem", "../pkg/tls/server.key")
	if err != nil {
		log.Fatalf("Failed to generate credentials %v", err)
	}
	// 新建gRPC服务器实例,并开启TLS认证
	grpcServer := grpc.NewServer(grpc.Creds(creds))
	// 在gRPC服务器注册我们的服务
	pb.RegisterSimpleServer(grpcServer, &SimpleService{})
	log.Println(Address + " net.Listing whth TLS and token...")
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
```

*   `credentials.NewServerTLSFromFile`：从输入证书文件和密钥文件为服务端构造TLS凭证
*   `grpc.Creds`：返回一个`ServerOption`，用于设置服务器连接的凭证。

### 客户端配置`TLS`连接

```go
var grpcClient pb.SimpleClient

func main() {
	//从输入的证书文件中为客户端构造TLS凭证
	creds, err := credentials.NewClientTLSFromFile("../pkg/tls/server.pem", "go-grpc-example")
	if err != nil {
		log.Fatalf("Failed to create TLS credentials %v", err)
	}
	// 连接服务器
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds))
	if err != nil {
		log.Fatalf("net.Connect err: %v", err)
	}
	defer conn.Close()

	// 建立gRPC连接
	grpcClient = pb.NewSimpleClient(conn)
}
```

*   `credentials.NewClientTLSFromFile`：从输入的证书文件中为客户端构造`TLS`凭证。
*   `grpc.WithTransportCredentials`：配置连接级别的安全凭证（例如，`TLS/SSL`），返回一个`DialOption`，用于连接服务器。

***

## `Token`认证

客户端发请求时，添加Token到上下文`context.Context`中，服务器接收到请求，先从上下文中获取`Token`验证，验证通过才进行下一步处理

### 客户端请求添加到`Token`到上下文

```go
type PerRPCCredentials interface {
    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
    RequireTransportSecurity() bool
}
```

gRPC 中默认定义了 `PerRPCCredentials`，是提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个RPC方法的上下文中。其包含 2 个方法：

*   `GetRequestMetadata`：获取当前请求认证所需的元数据
*   `RequireTransportSecurity`：是否需要基于 `TLS `认证进行安全传输

```go
// Token token认证
type Token struct {
	AppID     string
	AppSecret string
}

// GetRequestMetadata 获取当前请求认证所需的元数据（metadata）
func (t *Token) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{"app_id": t.AppID, "app_secret": t.AppSecret}, nil
}

// RequireTransportSecurity 是否需要基于 TLS 认证进行安全传输
func (t *Token) RequireTransportSecurity() bool {
	return true
}
```

然后再客户端中调用Dial时添加自定义验证方法进去

```go
//构建Token
	token := auth.Token{
		AppID:     "grpc_token",
		AppSecret: "123456",
	}
	// 连接服务器
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&token))
```

## 服务端验证`token`

首先需要从上下文中获取元数据，然后从元数据中解析Token进行验证

```go
// Check 验证token
func Check(ctx context.Context) error {
	//从上下文中获取元数据
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return status.Errorf(codes.Unauthenticated, "获取Token失败")
	}
	var (
		appID     string
		appSecret string
	)
	if value, ok := md["app_id"]; ok {
		appID = value[0]
	}
	if value, ok := md["app_secret"]; ok {
		appSecret = value[0]
	}
	if appID != "grpc_token" || appSecret != "123456" {
		return status.Errorf(codes.Unauthenticated, "Token无效: app_id=%s, app_secret=%s", appID, appSecret)
	}
	return nil
}

// Route 实现Route方法
func (s *SimpleService) Route(ctx context.Context, req *pb.SimpleRequest) (*pb.SimpleResponse, error) {
    //检测Token是否有效
	if err := Check(ctx); err != nil {
		return nil, err
	}
	res := pb.SimpleResponse{
		Code:  200,
		Value: "hello " + req.Data,
	}
	return &res, nil
}
```

*   `metadata.FromIncomingContext`：从上下文中获取元数据

## 服务端添加拦截器

服务端代码中，每个服务的方法都需要添加`Check(ctx)`来验证Token，这样十分麻烦。`gRPC拦截器`，能很好地解决这个问题。`gRPC拦截器`功能类似中间件，拦截器收到请求后，先进行一些操作，然后才进入服务的代码处理。

```go
func main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	// 从输入证书文件和密钥文件为服务端构造TLS凭证
	creds, err := credentials.NewServerTLSFromFile("../pkg/tls/server.pem", "../pkg/tls/server.key")
	if err != nil {
		log.Fatalf("Failed to generate credentials %v", err)
	}
	//普通方法：一元拦截器（grpc.UnaryInterceptor）
	var interceptor grpc.UnaryServerInterceptor
	interceptor = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
		//拦截普通方法请求，验证Token
		err = Check(ctx)
		if err != nil {
			return
		}
		// 继续处理请求
		return handler(ctx, req)
	}
	// 新建gRPC服务器实例,并开启TLS认证和Token认证
	grpcServer := grpc.NewServer(grpc.Creds(creds), grpc.UnaryInterceptor(interceptor))
	// 在gRPC服务器注册我们的服务
	pb.RegisterSimpleServer(grpcServer, &SimpleService{})
	log.Println(Address + " net.Listing whth TLS and token...")
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
}
```

*   `grpc.UnaryServerInterceptor`：为一元拦截器，只会拦截简单`RPC`方法。`流式RPC`方法需要使用流式拦截器`grpc.StreamInterceptor`进行拦截。

客户端发起请求，当Token不正确时候，会返回

```bash
Call Route err: rpc error: code = Unauthenticated desc = Token无效: app_id=grpc_token, app_secret=12345
```

***

# `go-grpc-middleware`使用

本篇简单介绍[go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)的使用，包括`grpc_zap`、`grpc_auth`和`grpc_recovery`。

## 简介安装

`go-grpc-middleware`封装了`认证（auth）, 日志（ logging）, 消息（message）, 验证（validation）, 重试（retries） 和监控（prometheus）`等拦截器。

*   安装 `go get github.com/grpc-ecosystem/go-grpc-middleware`
*   使用

```go
import "github.com/grpc-ecosystem/go-grpc-middleware"
myServer := grpc.NewServer(
    grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
        grpc_ctxtags.StreamServerInterceptor(),
        grpc_opentracing.StreamServerInterceptor(),
        grpc_prometheus.StreamServerInterceptor,
        grpc_zap.StreamServerInterceptor(zapLogger),
        grpc_auth.StreamServerInterceptor(myAuthFunction),
        grpc_recovery.StreamServerInterceptor(),
    )),
    grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
        grpc_ctxtags.UnaryServerInterceptor(),
        grpc_opentracing.UnaryServerInterceptor(),
        grpc_prometheus.UnaryServerInterceptor,
        grpc_zap.UnaryServerInterceptor(zapLogger),
        grpc_auth.UnaryServerInterceptor(myAuthFunction),
        grpc_recovery.UnaryServerInterceptor(),
    )),
)
```

`grpc.StreamInterceptor`中添加`流式RPC`的拦截器。
`grpc.UnaryInterceptor`中添加`简单RPC`的拦截器。

## `grpc_zap`记录

1.创建zap.Logger实例

```go
func ZapInterceptor() *zap.Logger {
	logger, err := zap.NewDevelopment()
	if err != nil {
		log.Fatalf("failed to initialize zap logger: %v", err)
	}
	grpc_zap.ReplaceGrpcLogger(logger)
	return logger
}
```

2.把zap拦截器添加到服务端

```go
grpcServer := grpc.NewServer(
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
		)),
```

![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200421150239484-1399156155.png)

各个字段代表的意思如下：

```json
{
	  "level": "info",						// string  zap log levels
	  "msg": "finished unary call",					// string  log message

	  "grpc.code": "OK",						// string  grpc status code
	  "grpc.method": "Ping",					/ string  method name
	  "grpc.service": "mwitkow.testproto.TestService",              // string  full name of the called service
	  "grpc.start_time": "2006-01-02T15:04:05Z07:00",               // string  RFC3339 representation of the start time
	  "grpc.request.deadline": "2006-01-02T15:04:05Z07:00",         // string  RFC3339 deadline of the current request if supplied
	  "grpc.request.value": "something",				// string  value on the request
	  "grpc.time_ms": 1.345,					// float32 run time of the call in ms

	  "peer.address": {
	    "IP": "127.0.0.1",						// string  IP address of calling party
	    "Port": 60216,						// int     port call is coming in on
	    "Zone": ""							// string  peer zone for caller
	  },
	  "span.kind": "server",					// string  client | server
	  "system": "grpc",						// string

	  "custom_field": "custom_value",				// string  user defined field
	  "custom_tags.int": 1337,					// int     user defined tag on the ctx
	  "custom_tags.string": "something"				// string  user defined tag on the ctx
}
```

4.把日志写到文件中

上面日志是在控制台输出的，现在我们把日志写到文件中，修改`ZapInterceptor`方法。

```go
import (
	grpc_zap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"gopkg.in/natefinch/lumberjack.v2"
)

// ZapInterceptor 返回zap.logger实例(把日志写到文件中)
func ZapInterceptor() *zap.Logger {
	w := zapcore.AddSync(&lumberjack.Logger{
		Filename:  "log/debug.log",
		MaxSize:   1024, //MB
		LocalTime: true,
	})

	config := zap.NewProductionEncoderConfig()
	config.EncodeTime = zapcore.ISO8601TimeEncoder
	core := zapcore.NewCore(
		zapcore.NewJSONEncoder(config),
		w,
		zap.NewAtomicLevel(),
	)

	logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))
	grpc_zap.ReplaceGrpcLogger(logger)
	return logger
}
```

## `grpc_auth`认证中心

`go-grpc-middleware`中的`grpc_auth`默认使用`authorization`认证方式，以authorization为头部，包括`basic`, `bearer`形式等。下面介绍`bearer token`认证。`bearer`允许使用`access key`（如`JSON Web Token (JWT)`）进行访问。

1.新建grpc\_auth服务端拦截器

```go
// TokenInfo 用户信息
type TokenInfo struct {
	ID    string
	Roles []string
}

// AuthInterceptor 认证拦截器，对以authorization为头部，形式为`bearer token`的Token进行验证
func AuthInterceptor(ctx context.Context) (context.Context, error) {
    token, err := grpc_auth.AuthFromMD(ctx, "bearer")				//  key: value    authorization: bearer grpc.auth.token
	if err != nil {
		return nil, err
	}
	tokenInfo, err := parseToken(token)
	if err != nil {
		return nil, grpc.Errorf(codes.Unauthenticated, " %v", err)
	}
	//使用context.WithValue添加了值后，可以用Value(key)方法获取值
	newCtx := context.WithValue(ctx, tokenInfo.ID, tokenInfo)
	//log.Println(newCtx.Value(tokenInfo.ID))
	return newCtx, nil
}

//解析token，并进行验证
func parseToken(token string) (TokenInfo, error) {
	var tokenInfo TokenInfo
	if token == "grpc.auth.token" {
		tokenInfo.ID = "1"
		tokenInfo.Roles = []string{"admin"}
		return tokenInfo, nil
	}
	return tokenInfo, errors.New("Token无效: bearer " + token)
}

//从token中获取用户唯一标识
func userClaimFromToken(tokenInfo TokenInfo) string {
	return tokenInfo.ID
}
```

> 注意：这里要以`authorization`为头部，和服务端对应。

2.客户端请求添加`bearer token`

实现和上篇的自定义认证方法大同小异。gRPC 中默认定义了 `PerRPCCredentials`，是提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个RPC方法的上下文中。其包含 2 个方法：

*   `GetRequestMetadata`：获取当前请求认证所需的元数据
*   `RequireTransportSecurity`：是否需要基于 `TLS `认证进行安全传输

接下来我们实现这两个方法

```go
// Token token认证
type Token struct {
	Value string
}

const headerAuthorize string = "authorization"

// GetRequestMetadata 获取当前请求认证所需的元数据
func (t *Token) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{headerAuthorize: t.Value}, nil
}

// RequireTransportSecurity 是否需要基于 TLS 认证进行安全传输
func (t *Token) RequireTransportSecurity() bool {
	return true
}
```

发送请求时添加token

```go
//从输入的证书文件中为客户端构造TLS凭证
	creds, err := credentials.NewClientTLSFromFile("../tls/server.pem", "go-grpc-example")
	if err != nil {
		log.Fatalf("Failed to create TLS credentials %v", err)
	}
	//构建Token
	token := auth.Token{
		Value: "bearer grpc.auth.token",
	}
	// 连接服务器
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&token))
```

> 注意：Token中的Value的形式要以`bearer token值`形式。因为我们服务端使用了`bearer token`验证方式。

3.把`grpc_auth`拦截器添加到服务端

```go
grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
		)),
	)
```

## `grpc_recovery`恢复

把`gRPC`中的`panic`转成`error`，从而恢复程序。

1.直接把`grpc_recovery`拦截器添加到服务端

最简单使用方式

```go
grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor,
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(),
		)),
	)
```

2.自定义错误返回

当`panic`时候，自定义错误码并返回。

```go
// RecoveryInterceptor panic时返回Unknown错误吗
func RecoveryInterceptor() grpc_recovery.Option {
	return grpc_recovery.WithRecoveryHandler(func(p interface{}) (err error) {
		return grpc.Errorf(codes.Unknown, "panic triggered: %v", p)
	})
}
```

添加`grpc_recovery`拦截器到服务端

```go
grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor(recovery.RecoveryInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(recovery.RecoveryInterceptor()),
		)),
	)
```

# `proto`数据验证

本篇将介绍`grpc_validator`，它可以对`gRPC`数据的输入和输出进行验证。

### 创建proto文件，添加验证规则

这里使用第三方插件[go-proto-validators](https://github.com/mwitkow/go-proto-validators)自动生成验证规则。

```bash
go get github.com/mwitkow/go-proto-validators
```

代码`import "github.com/mwitkow/go-proto-validators/validator.proto"`，文件`validator.proto`需要`import "google/protobuf/descriptor.proto";`包，不然会报错。

`google/protobuf`地址：<https://github.com/protocolbuffers/protobuf/tree/master/src/google/protobuf/descriptor.proto>

把`src`文件夹中的`protobuf`目录下载到`GOPATH`目录下。

1.新建`simple.proto`文件

```protobuf
syntax = "proto3";

package proto;

import "github.com/mwitkow/go-proto-validators/validator.proto";

message InnerMessage {
  // some_integer can only be in range (1, 100).
  int32 some_integer = 1 [(validator.field) = {int_gt: 0, int_lt: 100}];
  // some_float can only be in range (0;1).
  double some_float = 2 [(validator.field) = {float_gte: 0, float_lte: 1}];
}

message OuterMessage {
  // important_string must be a lowercase alpha-numeric of 5 to 30 characters (RE2 syntax).
  string important_string = 1 [(validator.field) = {regex: "^[a-z]{2,5}$"}];
  // proto3 doesn't have `required`, the `msg_exist` enforces presence of InnerMessage.
  InnerMessage inner = 2 [(validator.field) = {msg_exists : true}];
}

service Simple{
  rpc Route (InnerMessage) returns (OuterMessage){};
}
```

2.编译`simple.proto`文件

```
`go get github.com/mwitkow/go-proto-validators/protoc-gen-govalidators`

```

指令编译：`protoc --govalidators_out=. --go_out=plugins=grpc:./ ./simple.proto`

编译完成后，自动生成`simple.pb.go`和`simple.validator.pb.go`文件，

`simple.pb.go`文件不再介绍，我们看下`simple.validator.pb.go`文件。

检验代码已经产生,里面自动生成了`message`中属性的验证规则。

```go
// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-grpc-example/9-grpc_proto_validators/proto/simple.proto

package proto

import (
	fmt "fmt"
	math "math"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/mwitkow/go-proto-validators"
	regexp "regexp"
	github_com_mwitkow_go_proto_validators "github.com/mwitkow/go-proto-validators"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

func (this *InnerMessage) Validate() error {
	if !(this.SomeInteger > 0) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeInteger", fmt.Errorf(`value '%v' must be greater than '0'`, this.SomeInteger))
	}
	if !(this.SomeInteger < 100) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeInteger", fmt.Errorf(`value '%v' must be less than '100'`, this.SomeInteger))
	}
	if !(this.SomeFloat >= 0) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeFloat", fmt.Errorf(`value '%v' must be greater than or equal to '0'`, this.SomeFloat))
	}
	if !(this.SomeFloat <= 1) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeFloat", fmt.Errorf(`value '%v' must be lower than or equal to '1'`, this.SomeFloat))
	}
	return nil
}

var _regex_OuterMessage_ImportantString = regexp.MustCompile(`^[a-z]{2,5}$`)

func (this *OuterMessage) Validate() error {
	if !_regex_OuterMessage_ImportantString.MatchString(this.ImportantString) {
		return github_com_mwitkow_go_proto_validators.FieldError("ImportantString", fmt.Errorf(`value '%v' must be a string conforming to regex "^[a-z]{2,5}$"`, this.ImportantString))
	}
	if nil == this.Inner {
		return github_com_mwitkow_go_proto_validators.FieldError("Inner", fmt.Errorf("message must exist"))
	}
	if this.Inner != nil {
		if err := github_com_mwitkow_go_proto_validators.CallValidatorIfExists(this.Inner); err != nil {
			return github_com_mwitkow_go_proto_validators.FieldError("Inner", err)
		}
	}
	return nil
}
```

### 把`grpc_validator`验证拦截器添加到服务端

```go
grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			grpc_validator.StreamServerInterceptor(),
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor(recovery.RecoveryInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_validator.UnaryServerInterceptor(),
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(recovery.RecoveryInterceptor()),
		)),
	)
```

运行后，当输入数据验证失败后，会有以下错误返回

```bash
Call Route err: rpc error: code = InvalidArgument desc = invalid field SomeInteger: value '101' must be less than '100'
```

### 其他类型验证规则设置

`enum`验证

```protobuf
syntax = "proto3";
package proto;
import "github.com/mwitkow/go-proto-validators/validator.proto";

message SomeMsg {
  Action do = 1 [(validator.field) = {is_in_enum : true}];
}

enum Action {
  ALLOW = 0;
  DENY = 1;
  CHILL = 2;
}
```

`UUID`验证

```protobuf
syntax = "proto3";
package proto;
import "github.com/mwitkow/go-proto-validators/validator.proto";

message UUIDMsg {
  // user_id must be a valid version 4 UUID.
  string user_id = 1 [(validator.field) = {uuid_ver: 4, string_not_empty: true}];
}
```

`go-grpc-middleware`中`grpc_validator`集成`go-proto-validators`，我们只需要在编写`proto`时设好验证规则，并把`grpc_validator`添加到`gRPC`服务端，就能完成`gRPC`的数据验证，很简单也很方便。

# `gRPC`转成`HTTP`

## 编写和编译`proto`

```protobuf
syntax = "proto3";

package proto;

import "github.com/mwitkow/go-proto-validators/validator.proto";
//　grpc-gateway 主要使用
import "go-grpc-example/10-grpc-gateway/proto/google/api/annotations.proto";

message InnerMessage {
  // some_integer can only be in range (1, 100).
  int32 some_integer = 1 [(validator.field) = {int_gt: 0, int_lt: 100}];
  // some_float can only be in range (0;1).
  double some_float = 2 [(validator.field) = {float_gte: 0, float_lte: 1}];
}

message OuterMessage {
  // important_string must be a lowercase alpha-numeric of 5 to 30 characters (RE2 syntax).
  string important_string = 1 [(validator.field) = {regex: "^[a-z]{2,5}$"}];
  // proto3 doesn't have `required`, the `msg_exist` enforces presence of InnerMessage.
  InnerMessage inner = 2 [(validator.field) = {msg_exists : true}];
}

// 添加了API路由路径
service Simple{
  rpc Route (InnerMessage) returns (OuterMessage){
      option (google.api.http) ={
          post:"/v1/example/route"
          body:"*"
      };
  }
}
```

编译`simple.proto`

`simple.proto`文件引用了`google/api/annotations.proto`（[来源](https://github.com/grpc-ecosystem/grpc-gateway/tree/master/third_party/googleapis/google/api)）

我这里是把`google/`文件夹直接复制到项目中的`proto/`目录中进行编译。发现`annotations.proto`引用了`google/api/http.proto`，那把它也编译了。

进入`annotations.proto`所在目录，编译：

```bash
protoc --go_out=plugins=grpc:./ ./http.proto
protoc --go_out=plugins=grpc:./ ./annotations.proto
```

进入`simple.proto`所在目录，编译：

```bash
#生成simple.validator.pb.go和simple.pb.go
protoc --govalidators_out=. --go_out=plugins=grpc:./ ./simple.proto
#生成simple.pb.gw.go
protoc --grpc-gateway_out=logtostderr=true:./ ./simple.proto
```

以上完成`proto`编译，接着修改服务端代码。

## `server.go`服务端代码修改

1.`server/`文件夹下新建`gateway/`目录，然后在里面新建`gateway.go`文件

```go
package gateway

import (
	"context"
	"crypto/tls"
	"io/ioutil"
	"log"
	"net/http"
	"strings"

	pb "go-grpc-example/10-grpc-gateway/proto"
	"go-grpc-example/10-grpc-gateway/server/swagger"

	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/grpclog"
)

// ProvideHTTP 把gRPC服务转成HTTP服务，让gRPC同时支持HTTP
func ProvideHTTP(endpoint string, grpcServer *grpc.Server) *http.Server {
	ctx := context.Background()
	//获取证书
	creds, err := credentials.NewClientTLSFromFile("../tls/server.pem", "go-grpc-example")
	if err != nil {
		log.Fatalf("Failed to create TLS credentials %v", err)
	}
	//添加证书
	dopts := []grpc.DialOption{grpc.WithTransportCredentials(creds)}
    
	//新建gwmux，它是grpc-gateway的请求复用器。它将http请求与模式匹配，并调用相应的处理程序。
	gwmux := runtime.NewServeMux()
	//将服务的http处理程序注册到gwmux。处理程序通过endpoint转发请求到grpc端点
	err = pb.RegisterSimpleHandlerFromEndpoint(ctx, gwmux, endpoint, dopts)
	if err != nil {
		log.Fatalf("Register Endpoint err: %v", err)
	}
	//新建mux，它是http的请求复用器
	mux := http.NewServeMux()
	//注册gwmux
	mux.Handle("/", gwmux)
	log.Println(endpoint + " HTTP.Listing whth TLS and token...")
	return &http.Server{
		Addr:      endpoint,
		Handler:   grpcHandlerFunc(grpcServer, mux),
		TLSConfig: getTLSConfig(),
	}
}

// grpcHandlerFunc 根据不同的请求重定向到指定的Handler处理
func grpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {
	return h2c.NewHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	}), &http2.Server{})
}

// getTLSConfig获取TLS配置
func getTLSConfig() *tls.Config {
	cert, _ := ioutil.ReadFile("../tls/server.pem")
	key, _ := ioutil.ReadFile("../tls/server.key")
	var demoKeyPair *tls.Certificate
	pair, err := tls.X509KeyPair(cert, key)
	if err != nil {
		grpclog.Fatalf("TLS KeyPair err: %v\n", err)
	}
	demoKeyPair = &pair
	return &tls.Config{
		Certificates: []tls.Certificate{*demoKeyPair},
		NextProtos:   []string{http2.NextProtoTLS}, // HTTP2 TLS支持
	}
}

```

它主要作用是把不用的请求重定向到指定的服务处理，从而实现把`HTTP`请求转到`gRPC`服务。

1.  `gRPC`支持HTTP

```go
    //使用gateway把grpcServer转成httpServer
	httpServer := gateway.ProvideHTTP(Address, grpcServer)
	if err = httpServer.Serve(tls.NewListener(listener, httpServer.TLSConfig)); err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
```

#### 使用postman测试![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426190917132-305705093.gif)

在动图中可以看到，我们的`gRPC`服务已经同时支持`RPC`和`HTTP`请求了，而且`API`接口支持`bearer token`验证和数据验证。为了方便对接，我们把`API`接口生成`swagger`文档。

## 生成`swagger`文档

### 生成`swagger`文档-`simple.swagger.json`

#### 安装`protoc-gen-swagger`

```bash
go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger
```

#### 编译生成`simple.swagger.json`

到simple.proto文件目录下，编译：
`protoc --swagger_out=logtostderr=true:./ ./simple.proto`

或者使用`vscode-proto3`插件

```json
  // vscode-proto3插件配置
    "protoc": {
        // protoc.exe所在目录
        "path": "/usr/bin/protoc",
        // 保存时自动编译
        "compile_on_save": true,
        "options": [
            "--go_out=plugins=grpc:.",//在当前目录编译输出.pb.go文件
            "--govalidators_out=.",//在当前目录编译输出.validator.pb文件
            "--grpc-gateway_out=logtostderr=true:.",//在当前目录编译输出.pb.gw.go文件
            "--swagger_out=logtostderr=true:."//在当前目录编译输出.swagger.json文件
        ]
    }
```

#### 把`swagger-ui`转成`Go`代码

1.下载`swagger-ui`

[下载地址](https://github.com/swagger-api/swagger-ui)，把`dist`目录下的所有文件拷贝我们项目的`server/swagger/swagger-ui/`目录下。

2.把`Swagger UI`转换为Go代码

安装`go-bindata`：
`go get -u github.com/jteeuwen/go-bindata/...`

回到`server/`所在目录，运行指令把`Swagger UI`转成Go代码。
`go-bindata --nocompress -pkg swagger -o swagger/datafile.go swagger/swagger-ui/...`

*   这步有坑，必须要回到`main`函数所在的目录运行指令，因为生成的Go代码中的`_bindata` 映射了`swagger-ui`的路径，程序是根据这些路径来找页面的。如果没有在`main`函数所在的目录运行指令，则生成的路径不对，会报404，无法找到页面。本项目`server/`端的`main`函数在`server.go`中，所以在`server/`所在目录下运行指令。

```go
var _bindata = map[string]func() (*asset, error){
	"swagger/swagger-ui/favicon-16x16.png": swaggerSwaggerUiFavicon16x16Png,
	"swagger/swagger-ui/favicon-32x32.png": swaggerSwaggerUiFavicon32x32Png,
	"swagger/swagger-ui/index.html": swaggerSwaggerUiIndexHtml,
	"swagger/swagger-ui/oauth2-redirect.html": swaggerSwaggerUiOauth2RedirectHtml,
	"swagger/swagger-ui/swagger-ui-bundle.js": swaggerSwaggerUiSwaggerUiBundleJs,
	"swagger/swagger-ui/swagger-ui-bundle.js.map": swaggerSwaggerUiSwaggerUiBundleJsMap,
	"swagger/swagger-ui/swagger-ui-standalone-preset.js": swaggerSwaggerUiSwaggerUiStandalonePresetJs,
	"swagger/swagger-ui/swagger-ui-standalone-preset.js.map": swaggerSwaggerUiSwaggerUiStandalonePresetJsMap,
	"swagger/swagger-ui/swagger-ui.css": swaggerSwaggerUiSwaggerUiCss,
	"swagger/swagger-ui/swagger-ui.css.map": swaggerSwaggerUiSwaggerUiCssMap,
	"swagger/swagger-ui/swagger-ui.js": swaggerSwaggerUiSwaggerUiJs,
	"swagger/swagger-ui/swagger-ui.js.map": swaggerSwaggerUiSwaggerUiJsMap,
}
```

#### 对外提供`swagger-ui`

1.在`swagger/`目录下新建`swagger.go`文件

```go
package swagger

import (
	"log"
	"net/http"
	"path"
	"strings"

	assetfs "github.com/elazarl/go-bindata-assetfs"
)

//ServeSwaggerFile 把proto文件夹中的swagger.json文件暴露出去
func ServeSwaggerFile(w http.ResponseWriter, r *http.Request) {
	if !strings.HasSuffix(r.URL.Path, "swagger.json") {
		log.Printf("Not Found: %s", r.URL.Path)
		http.NotFound(w, r)
		return
	}

	p := strings.TrimPrefix(r.URL.Path, "/swagger/")
	// "../proto/"为.swagger.json所在目录
	p = path.Join("../proto/", p)

	log.Printf("Serving swagger-file: %s", p)

	http.ServeFile(w, r, p)
}

//ServeSwaggerUI 对外提供swagger-ui
func ServeSwaggerUI(mux *http.ServeMux) {
	fileServer := http.FileServer(&assetfs.AssetFS{
		Asset:    Asset,
		AssetDir: AssetDir,
		Prefix:   "swagger/swagger-ui", //swagger-ui文件夹所在目录
	})
	prefix := "/swagger-ui/"
	mux.Handle(prefix, http.StripPrefix(prefix, fileServer))
}
```

2.注册`swagger`

在`gateway.go`中添加如下代码

```go
        //注册swagger
        mux.HandleFunc("/swagger/", swagger.ServeSwaggerFile)
        swagger.ServeSwaggerUI(mux)
```

到这里我们已经完成了`swagger`文档的添加工作了，由于谷歌浏览器不能使用自己制作的TLS证书，所以我们用火狐浏览器进行测试。

用火狐浏览器打开：<https://127.0.0.1:8000/swagger-ui/>

在最上面地址栏输入：<https://127.0.0.1:8000/swagger/simple.swagger.json>

然后就可以看到`swagger生成的API文档`了。

![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426200056107-1097342377.png)

### 怎么把`bearer token`也添加到`swagger`中呢？

我们使用了bearer token进行接口验证的，怎么把`bearer token`也添加到swagger中呢？
最后我在`grpc-gateway`GitHub上的这个[Issues](https://github.com/grpc-ecosystem/grpc-gateway/issues/1089)找到解决办法。

#### 在swagger中配置`bearer token`

1.修改`simple.proto`文件

```protobuf
syntax = "proto3";

package proto;

import "github.com/mwitkow/go-proto-validators/validator.proto";
import "go-grpc-example/10-grpc-gateway/proto/google/api/annotations.proto";
// 增加options
import "go-grpc-example/10-grpc-gateway/proto/google/options/annotations.proto";

message InnerMessage {
  // some_integer can only be in range (1, 100).
  int32 some_integer = 1 [(validator.field) = {int_gt: 0, int_lt: 100}];
  // some_float can only be in range (0;1).
  double some_float = 2 [(validator.field) = {float_gte: 0, float_lte: 1}];
}

message OuterMessage {
  // important_string must be a lowercase alpha-numeric of 5 to 30 characters (RE2 syntax).
  string important_string = 1 [(validator.field) = {regex: "^[a-z]{2,5}$"}];
  // proto3 doesn't have `required`, the `msg_exist` enforces presence of InnerMessage.
  InnerMessage inner = 2 [(validator.field) = {msg_exists : true}];
}

option (grpc.gateway.protoc_gen_swagger.options.openapiv2_swagger) = {
  security_definitions: {
    security: {
      key: "bearer"
      value: {
        type: TYPE_API_KEY
        in: IN_HEADER
        name: "Authorization"
        description: "Authentication token, prefixed by Bearer: Bearer <token>"
      }
    }
  }

  security: {
    security_requirement: {
      key: "bearer"
    }
  }

  info: {
		title: "grpc gateway sample";
		version: "1.0";	
		license: {
			name: "MIT";			
		};
  }

  schemes: HTTPS
};

service Simple{
  rpc Route (InnerMessage) returns (OuterMessage){
      option (google.api.http) ={
          post:"/v1/example/route"
          body:"*"
      };
      // //禁用bearer token
      // option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
      //   security: { } // Disable security key
      // };
  }
}
```

验证测试

![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201427202-713287948.gif)

调用接口，正确返回数据

![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201751447-2114446576.png)

## 总结：

本篇介绍了如何使用`grpc-gateway`让`gRPC`同时支持HTTP，最终转成的`Restful Api`支持`bearer token`验证、数据验证。同时生成`swagger`文档，方便`API`接口对接。
