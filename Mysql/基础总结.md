# SQL执行过程

![](https://segmentfault.com/img/bVbfddI?w=855\&h=707)

# 一条更新SQl语句执行过程

1.  执行器先找引擎对应id行, 直接用B+树 搜索找到,如果在内存里就找内存&#x20;
2.  上排它锁, 拿到行数据 + 1 得到新数据, 调用引擎接口写入这行数据&#x20;
3.  同时更新到内存, 写下更新记录到redo\_log --prepare&#x20;
4.  引擎执行完告诉执行器,可以提交事务
5.  生成binlog 并写入磁盘&#x20;
6.  执行器调用引擎提交事务, redo\_log ->commit ,更新完成

# `Mysql`日志作用

`binlog -- mysql`级别日志 用于记录完成的mysql操作-- 主从复制就是通过`binlog通讯`

`Undo日志`-- 记录数据原本的样子--修改操作时候就会先写入Undo

`Redo日志`-- 记录数据更改后的样子,刷入磁盘才算真的落盘 ![](https://img-blog.csdnimg.cn/20190302122208564.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_16,color_FFFFFF,t_70)

# ACID

事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。&#x20;

`原子性（Actomicity）`：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。--使用Redo& Undo

`一致性（Consistent）`：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。  --Undo

`隔离性（Isolation）`：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。----这里就使用数据库的Lock

`持久性（Durable）`：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。--Redo

而事务的`ACID是通过InnoDB日志和锁来保证`。事务的隔离性是通过数据库锁的机制实现的，持久性通过`redo log（重做日志）`来实现，原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

和Undo Log相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。

A 原子性--原子锁-- Redo\&Undo 日志

C一致性: 事务开始和完成时数据都必须保持一致状态--Undo

I -- 隔离性: Lock锁--Mysql innodb引擎是行锁级别

D -- 持久性-- 数据修改是永久的 Redo

写入过程如下：当向数据库写入数据时，执行过程会首先写入redo log buffer，redo log buffer中修改的数据会定期刷新到磁盘的redo log文件中，这一过程称为刷盘（即redo log buffer写日志到磁盘的redo log file中 ）。

# 脏读, 不可重复读,幻读

`脏读`: 就是T1事务读到了T2事务提交了的数据,而T2直接回滚了,T1事务读到的数据就是无效的; -- `读未提交`

读取已提交会产生不可重复读：比如A事务读取数据，开始是100，事务还没有提交，此时B事务对这个数据修改为80，然后提交了事务，此时A事务再次读取就是80，因为B已经提交了，但是两次的结果不一样，就产生了`不可重复读的现象`。

`可重复读`：在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据

`幻读`:  就是第一个事务查询id>3后, 插入了id=6的数据 准备提交前,第二个事务就已经提交了这个id=6的数据,这时候就报错了因为重复提交, 或者提交id > 3的其他数据,事务1相比第一次查询就会多出来数据

MySQL 采用的是 `MVCC 机制来解决脏读、不可重复读的问题`。 解决脏读: MVCC 解决了一致性读问题，当我们读取某个数据库在时间点的快照时，只能看到时间点之前提交更新的结果，不能看到时间点之后事务提交的更新结果。这样就避免了脏读问题。

解决`不可重复读`: -- 先看MVCC原理中的`Read View` 模型 ReadView 中保存了当前活跃的事务列表。通过比较事务版本，可以判断当前行数据版本是不是对当前事务可见。 ![](https://img-blog.csdnimg.cn/img_convert/c57d6fbddb13d345954a3f19beedeab2.png)

解决幻读 使用的是 Next-key Lock : 行锁+ Gap Lock（间隙锁）

比如:
`select * from tb where id>100 for update;` 主键索引 id 会给 id=100 的记录加上 `record行锁` 索引 id 上会加上` gap 锁`，锁住 id(100,+无穷大）这个范围 其他事务对  id>100 范围的记录读和写操作都将被阻塞

插入 id=1000的记录时候会命中索引上加的锁会报出事务异常；

# 四种事务隔离级别 --innodb

1\ 读未提交-- 最低级别 只保证数据不损坏 --出现脏读等所有问题
2\ 不可重复读(读已提交)- -- 提交一次就读一次 不存在事务  -- 出现不可重复读和幻读
3\ 可重复读 -- 事务级别 会出现 幻读(范围查询时候不一样)
幻读: 就是第一个事务查询id>3后, 插入了id=6的数据 准备提交前,第二个事务就已经提交了这个id=6的数据,这时候就报错了因为重复提交, 或者提交id > 3的其他数据,事务1相比第一次查询就会多出来数据
4\ 可序列化-- 最高级别--单线程类似

# 锁的模式 -- 事务的隔离性的实现就是通过 锁和MVCC

行锁: -- 只有innodb有
行锁就是通过给索引上的索引项加锁实现的--事务结束了才会释放
1\ 排他锁--写锁
2\ 共享锁-- 针对查询--读锁

表锁:
意向排他锁:意向共享锁:
数据插入需要意向排它锁

锁的实现算法:

&#x20;1- `Record Lock 记录锁`

2- `为了防止幻读`: 使用间隙锁--在查询数据间隙中插入锁, 记录位置

MVCC 多版本并发控制
有了锁，当前事务没有写锁就不能修改数据，但还是能读的，而且读的时候，即使该行数据其他事务已修改且提交，还是可以重复读到同样的值。 -- 所以就需要MVCC了
使用到版本链
1-DATA\_TRX\_ID：数据行版本号。用来标识最近对本行记录做修改的事务 id。 -- 就是使用当前事务id对比版本号 得出 是否显示当前数据的
2- DATA\_ROLL\_PTR：指向该行回滚段的指针。该行记录上所有旧版本，在 undo log 中都通过链表的形式组织。

# Mysql索引原理

场景:
where 使用索引
group by order by

索引类型:
1\ 聚簇索引: 存储顺序与索引值顺序一致, 一个基本表只有一个聚簇索引
聚簇索引就是按照每张表的主键构造一颗B+树,同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分；

2\ 非聚簇索引一般成为二级索引

# 索引最左侧原则(组合索引)

where 条件中
索引是 01 02 03

只有 02 03 是用不了索引的

只有 01 03 只有01 用到了索引

Mysql 从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，而且当最左侧字段是常量引用时，索引就十分有效，这就是最左前缀原则。

# 索引的数据结构

为什么使用B+tree
磁盘局部性预读,一次读一定长度数据放入内存

1\ B+ Tree
B+Tree索引在查找时需要从根节点到叶节点进行多次IO操作，在查询速度比不上Hash索引，但是更适合排序等操作。

优点: 叶子节点存储数据,每次Io读取更多行, 大大减少磁盘IO次数

叶子节点带有链表指向相邻叶子,可以顺序范围访问

对比B树索引

B+ 有利于数据库扫描 , 磁盘IO代价更低 , 查询效率稳定, 深度一致

# Mysql主从复制

Slave和Master之间的数据有可能存在延迟的现象，只能保证数据最终的一致性

在master和slave之间实现整个复制过程主要由三个线程来完成：
1\ Slave SQL thread 线程-- 创建用于读取relay log中继日志并执行更新 在slave端
2\ Slave IO 线程 读取Master服务器 Binlog Dump线程发送内容-> relaylog 中
3\ Binlog dump thread 将binlog发送到slave中

# 主从复制流程

1\ master 执行sql ->记录 binlog
2\ slave 连接master, 请求从指令binlog指定pos节点地方开始复制
3\ master收到slave请求后, 通知负责复制进程的IO线程, 读取Binlog返回给slave
4\ slave收到信息 依次写入slave的relaylog末端 ,记录位置,以便下次同步知道从哪个位置开始数据同步
5\ slave SQL线程检测relaylog新增后,进行写入,达到最终一致性

# 复制类型--也是binlog写入的类型

1\ 基于语句复制 -- 效率高
优点: 记录SQL语句 占用小空间
缺点: 不太安全 ,使用了Limit 但是没Order by 就不会被记录
对于没索引条件的update insert 会锁定更多数据 ,性能降低

2\ 基于行复制
最安全, update insert 锁定更小行
缺点: 文件比较大 ,操作时间长点

3\ 混合类型-- 默认采用语句 一旦无法精准复制,会采用基于行
